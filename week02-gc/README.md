#GCLogAnalysis
# G1 统计
128M 总暂停时间：0.15s  GC次数69次   fullGC15次 触发oom\  
256M 总暂停时间：0.29s  GC次数170次  fullGC36次 触发oom\
512M 总暂停时间：0.55s  GC次数126次  fullGC2次\
1024M 总暂停时间：0.33s GC次数33次  \
2048M 总暂停时间：0.39s GC次数6次  fullGC2次\
  

# Parallel 统计
128M 总暂停时间：0.21s  GC次数26次   fullGC13次 触发oom\
256M 总暂停时间：0.87s  GC次数35次   fullGC25次 \
512M 总暂停时间：0.73s  GC次数33次   fullGC7次 \
1024M 总暂停时间：0.53s GC次数19次   fullGC1次 \
2048M 总暂停时间：0.39s GC次数6次   

# Serial 统计
128M 总暂停时间：0.27s  GC次数24次   fullGC18次  触发oom\
256M 总暂停时间：0.85s  GC次数37次   fullGC30次 \
512M 总暂停时间：0.64s  GC次数22次   fullGC6次 \
1024M 总暂停时间：0.51s GC次数11次   fullGC1次 \
2048M 总暂停时间：0.46s GC次数5次  

# 总结
###Serial
本机没法模拟单核机器，被其他几种GC吊锤。
###Parallel
在低于2G时，有不错的性能表现，但是本身更关注于吞吐量，所以在Web环境下，能上G1就上G1
###CMS
更关注于响应时间
+ 初始标记 stw
+ 并发标记 与用户线程并发执行
+ 重新标记：并发标记过程中，可能有垃圾产生，需要stw
+ 并发清除，与用户线程同时执行（这个时候的垃圾呢？） \
实测和G1比没有啥优势
###G1
目前看来是除了ZGC外最好的选择，可惜我那生产是jdk8，上不到
简单的增加内存，即可明显的增加吞吐量，但是最好选择合适的GC算法，内存较大时，选择G1，当内存较小时，如果CPU性能足够好，选择ParallelGC能有比G1和SerialGC更好的表现。  
其次，对于常用的web应用，一般保证的都是用户的体验，响应时间大于吞吐量，此时CMS和G1是更好的选择，Parallel更注重与吞吐量，适合处理批量计算。
当CPU性能足够好时，可以适当增加50%的gc线程，能有意外惊喜，实测G1和Parallel的QPS有明显上升.
最后测试了下G1和zgc，在2G以下，两者